# -*- coding: utf-8 -*-
"""
/***************************************************************************
 bpla_plugin_flightsDialog
                                 A QGIS plugin
 Selecting and deleting odds and ends of flights.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-13
        git sha              : $Format:%H$
        copyright            : (C) 2021 by SibGis
        email                : sibgis@qgis.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os

from PyQt5.QtGui import QIcon
from qgis.PyQt import uic, QtGui
from qgis.PyQt import QtWidgets
from PyQt5.QtGui import *

from time import perf_counter

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
from PyQt5.QtWidgets import QAbstractItemView

from .tools.mathUtil.DataTimeUtil import DataTimeUtil
from .tools.dataStorage.FeaturesList import FeaturesList
from .tools.ClassificationTool import ClassificationTool
from .tools.dataStorage.FileManager import FileManager
from .tools.GuiElemIFace import GuiElemIFace

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bpla_plugin_flights_dialog_base.ui'))


class bpla_plugin_flightsDialog(QtWidgets.QDialog, FORM_CLASS):

    def __init__(self, parent=None):
        """Constructor."""
        super(bpla_plugin_flightsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.initForm()
        self.tabWidget.setCurrentIndex(0)
        self.tabWidget.currentChanged.connect(self.initForm)

        # input from combobox
        self.tb_reload_1.setIcon(QIcon(':/plugins/bpla_plugin_flights/icons/icon_reload.png'))
        self.tb_reload_1.clicked.connect(self.initForm)

        # input from folder/file
        self.tb_input_2.clicked.connect(self.setInputLineEditWithFilepath)
        # self.le_input_2.setText(r'/Users/ronya/My_Documents')

        # set combobox with out_fields
        self.tb_reload_2.setIcon(QIcon(':/plugins/bpla_plugin_flights/icons/icon_reload.png'))
        self.tb_reload_2.clicked.connect(self.setComboBoxWithFields)
        # self.initComboBoxWithFields()
        # self.cb_lyr_1.currentIndexChanged.connect(self.initComboBoxWithFields)

        # set data out_fields by radioButtons
        self.rb_simpleData.clicked.connect(self.hideParsedDataWidgets)
        self.rb_absoluteData.clicked.connect(self.hideParsedDataWidgets)
        self.rb_parsedData.clicked.connect(self.loadDataForParsedTime)

        # extension radioButtons
        self.txtParams = None
        self.rb_extensions = [self.rb_txt, self.rb_shp]

        # save output
        self.tb_output.clicked.connect(self.setOutputLineEditWithFilepath)
        # self.le_output.setText(r'/Users/ronya/My_Documents/output/test1.shp')
        # self.le_output.setText(r'/Users/ronya/My_Documents/Darhan/test/test_2.shp')

        self.pushButton_run.clicked.connect(self.doResult)

    def initForm(self):  # input combobox
        self.resize(800, 300)
        # self.adjustSize()
        self.chb_join.setVisible(False)
        self.gb_txtParams.setVisible(False)
        self.hideParsedDataWidgets()
        GuiElemIFace().setComboBoxWithLayers(self.cb_lyr_1)

    def setComboBoxWithFields(self):
        lg = FileManager()
        guiUtil = GuiElemIFace()

        if self.tabWidget.currentIndex() == 0:
            textFromCB = self.cb_lyr_1.currentText()
            if textFromCB != '':
                vlayer = lg.getQgsVectorLayer(textFromCB)
                guiUtil.setComboBox(self.cb_fields, list(vlayer.fields().names()))
        else:
            inputDir = self.le_input_2.text()
            file = lg.getFirstFileAttrFromDir(inputDir)

            if file.getFileExtension() == '.txt':
                fields = lg.getFieldsFromTXT(file.getFilePath())
                guiUtil.setComboBox(self.cb_fields, fields)

            elif file.getFileExtension() == '.shp':
                vlayer = lg.getQgsVectorLayer(file)
                guiUtil.setComboBox(self.cb_fields, list(vlayer.fields().names()))

    def setInputLineEditWithFilepath(self):  # input folder
        self.le_input_2.setText(QtWidgets.QFileDialog(self).getExistingDirectory(self, r'/Users/ronya/My_Documents'))
        # если первый файл в папке - текст, то покажем дополнительные параметры
        self.gb_txtParams.setVisible(False)
        inputDir = self.le_input_2.text()
        file = FileManager().getFirstFileAttrFromDir(inputDir)

        if file is not None and file.getFileExtension() == '.txt':
            self.gb_txtParams.setVisible(True)
            self.initTXTParams(file)

    def initTXTParams(self, file):
        guiUtil = GuiElemIFace(self.textEdit)
        fields = FileManager().getFieldsFromTXT(file.getFilePath())

        guiUtil.setComboBox(self.tp_delimiter, ['Tab'])
        guiUtil.setComboBox(self.tp_xfield, fields)
        guiUtil.setComboBox(self.tp_yfield, fields)

    def hideParsedDataWidgets(self):
        self.label_6.setVisible(False)
        self.listWidget.setVisible(False)

    def loadDataForParsedTime(self):
        self.cb_fields.clear()
        self.label_6.setVisible(True)
        self.listWidget.setVisible(True)
        lg = FileManager()
        guiUtil = GuiElemIFace()
        textFromCB = self.cb_lyr_1.currentText()

        if self.tabWidget.currentIndex() == 0:
            if textFromCB != '':
                vlayer = lg.getQgsVectorLayer(textFromCB)
                entries = list(vlayer.fields().names())
                guiUtil.setListWidgetWithData(self.listWidget, entries, 'multiselect')
        else:
            inputDir = self.le_input_2.text()
            file = lg.getFirstFileAttrFromDir(inputDir)

            if file.getFileExtension() == '.txt':
                entries = lg.getFieldsFromTXT(file.getFilePath())
                guiUtil.setListWidgetWithData(self.listWidget, entries, 'multiselect')

            elif file.getFileExtension() == '.shp':
                vlayer = lg.getQgsVectorLayer(file)
                entries = list(vlayer.fields().names())
                guiUtil.setListWidgetWithData(self.listWidget, entries, 'multiselect')

    def setOutputLineEditWithFilepath(self):  # output folder/file
        dlg = QtWidgets.QFileDialog(self)

        if self.chb_join.isChecked() or self.tabWidget.currentIndex() == 0:
            filter = '*' + GuiElemIFace().getTextFromRadioButton(self.rb_extensions)
            fn = dlg.getSaveFileName(self, 'Save file', r'/Users/ronya/My_Documents', filter=filter)[0]
        else:
            fn = dlg.getExistingDirectory(self, r'/Users/ronya/My_Documents')

        self.le_output.setText(fn)

    def mainAlgorithm(self, file_attr):
        """
            Функция удаления точек для каждого выбранного пользователем слоя,
                которая может выполняться несколько раз в теле цикла.
        """
        guiUtil = GuiElemIFace(self.textEdit)
        lg = FileManager(guiUtil)

        # создаем вектор qgis
        vlayer = lg.getQgsVectorLayer(file_attr[0], self.txtParams)
        features = FeaturesList(vlayer.fields().names(), [f.type() for f in vlayer.fields()], vlayer.getFeatures())
        field_data = self.cb_fields.currentText()

        if self.chb_delNulPnt.isChecked():  # удаляем нулевые точки, если поставлена галочка
            features.removeNullPoints()

        # если дата раздроблена, то собираем ее в одну строку и записываем в столбец TIME_REBUILT
        if self.rb_parsedData.isChecked():
            in_fields = self.listWidget.selectedItems()
            field_names = [i.text() for i in list(in_fields)]  # ['day', 'month', 'year', 'hour', 'minute', 'fn2']
            features = DataTimeUtil().joinDataFromDust(features, field_names)
            field_data = 'TIME'

        # основной алгоритм
        features = ClassificationTool(self.sb_accuracy.value(), self.sb_bufSize.value(), field_data,
                                      True, self.rb_absoluteData.isChecked(),
                                      guiUtil).mainAzimutCalc(features)

        if self.chb_delSpldPnt.isChecked():  # удаляем забракованные точки, если поставлена галочка
            features.removeSpoiledPoints()

        # записываем объекты в новый слой
        whatType = {'txt': self.rb_txt.isChecked(),
                    'shp': self.rb_shp.isChecked()
                    }
        mess = lg.createNewFileByExtension(whatType, features, file_attr[1].getFilePath())
        guiUtil.setOutputStyle(mess)

    def doResult(self):
        """Функция модуля удаления точек, которая выполняется первой при нажатии кнопки запуска плагина."""
        start = perf_counter()
        self.textEdit.setText('')

        lg = FileManager()
        guiUtil = GuiElemIFace(self.textEdit)

        # если выбран слой из комбобокса
        if self.tabWidget.currentIndex() == 0:
            save_file_attr = lg.getSaveFileAttr(self.le_output)
            layerName = self.cb_lyr_1.currentText()

            self.mainAlgorithm([layerName, save_file_attr])

        # если выбрана папка с множеством исходных файлов
        else:
            save_file_attr = lg.getSaveFileAttr(self.le_output, True)
            inputDir = self.le_input_2.text()
            saveFolderPath = save_file_attr.getDirPath()
            save_ext = guiUtil.getTextFromRadioButton(self.rb_extensions)
            file_attr = lg.getFilesAttrFromDir(inputDir, saveFolderPath, save_ext)

            # get txt params
            if self.gb_txtParams.isVisible():
                self.txtParams = {'delimiter': self.tp_delimiter.currentText(),
                                  'xfield': self.tp_xfield.currentText(),
                                  'yfield': self.tp_yfield.currentText(),
                                  'crs': self.tp_crs.text()
                                  }

            for file in file_attr:
                self.mainAlgorithm(file)

        end = perf_counter()
        guiUtil.setOutputStyle([0, '\nВремя работы плагина: ' + str(end - start)])
