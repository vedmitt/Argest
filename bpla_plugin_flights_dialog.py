# -*- coding: utf-8 -*-
"""
/***************************************************************************
 bpla_plugin_flightsDialog
                                 A QGIS plugin
 Selecting and deleting odds and ends of flights.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-13
        git sha              : $Format:%H$
        copyright            : (C) 2021 by SibGis
        email                : sibgis@qgis.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import math
import os
from datetime import datetime

from PyQt5.QtCore import QVariant
from PyQt5.QtGui import QIcon
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtGui import *
from qgis.core import *

from osgeo import ogr
import sys

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
from qgis.utils import iface

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bpla_plugin_flights_dialog_base.ui'))


class bpla_plugin_flightsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(bpla_plugin_flightsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.initActiveLayersComboBox()
        self.toolButton_cbreload.setIcon(QIcon(':/plugins/bpla_plugin_flights/icon_reload.png'))
        self.toolButton_cbreload.clicked.connect(self.initActiveLayersComboBox)
        self.checkBox.setChecked(True)
        self.toolButton.clicked.connect(self.getSaveFileName)
        self.pushButton.clicked.connect(self.doResult)

    def initActiveLayersComboBox(self):
        canvas = iface.mapCanvas()
        layers = canvas.layers()
        self.actVecLyrDict = {}
        self.comboBox.clear()
        for layer in layers:
            if ((type(layer) == QgsVectorLayer) and (layer.geometryType() == 0)):
                # setdefault добавляет элементы с проверкой на повторяющиеся
                # если у пользователя два слоя с одиноковыми именами, в комбобокс попадет только один из них
                self.actVecLyrDict.setdefault(layer.name(), layer)
        self.comboBox.addItems(self.actVecLyrDict.keys())
        self.comboBox.show()

    def getSaveFileName(self):
        dlg = QtWidgets.QFileDialog(self)
        fn = dlg.getSaveFileName(self, 'Save file', r'M:\Sourcetree\bpla_plugin_flights\output\test', filter='*.shp')[0]
        self.lineEdit.setText(fn)

    def getLayer(self):
        # get layer from combobox
        self.layer = self.actVecLyrDict.get(self.comboBox.currentText())
        if self.layer is None:
            self.textEdit.append('Слой не выбран!\n')
        else:
            self.layername = self.layer.name()
            cur_lyr_path = self.layer.dataProvider().dataSourceUri()

            if self.layer.dataProvider().storageType() == 'ESRI Shapefile':
                self.driverName = self.layer.dataProvider().storageType()
                char_arr = cur_lyr_path.split('|')
                self.layerpath = char_arr[0]

            elif self.layer.dataProvider().storageType() == 'Delimited text file':
                self.driverName = 'delimitedtext'
                fn = cur_lyr_path.split('?')
                fn = fn[0].split('///')
                self.layerpath = fn[1]

    def getFilepath(self):
        # get file name from line edit
        if self.lineEdit.text() != '':
            self.filepath = self.lineEdit.text()
            fn = os.path.basename(self.filepath)
            fn = fn.split('.shp')
            self.filename = fn[0]
        else:
            self.lineEdit.setText("Файл для сохранения не выбран!\n")

    def setTextStyle(self, color, weight):
        colors = {
            'black': QColor(0, 0, 0),
            'red': QColor(255, 0, 0),
            'green': QColor(51, 153, 0)
        }
        weights = {
            'normal': 1,
            'bold': QFont.Bold
        }
        self.textEdit.setTextColor(colors.get(color))
        self.textEdit.setFontWeight(weights.get(weight))

    def uploadLayer(self, filepath, filename, typeOfFile):
        # show our new layer in qgis
        layer = iface.addVectorLayer(filepath, filename, typeOfFile)
        if not layer:
            self.textEdit.append('Не удалось загрузить слой в оболочку!\n')

    def layerToMemory(self):
        try:
            self.textEdit.append('Создаем новый слой...')

            # # open an input datasource
            # # driverName = self.layer.dataProvider().storageType()
            inDriver = ogr.GetDriverByName(self.driverName)
            self.inDS = inDriver.Open(self.layerpath, 0)

            # self.inDS = ogr.Open(self.layerpath, 0)
            # fn = os.path.split(self.layerpath)
            # inDS = ogr.Open(fn[0], 0)

            # if inDS is None:  # добавить обработчик исключений
            #     # sys.exit('Could not open folder.')
            #     self.textEdit.append('Произошла ошибка при создании файла!')
            #     # return ['Произошла ошибка при создании файла!', 0]

            # Get the input shapefile
            in_lyr = self.inDS.GetLayer()
            # in_lyr = QgsVectorLayer(self.layer.dataProvider().dataSourceUri(), self.layerpath, "delimitedtext")

            self.textEdit.append('Количество точек в оригинальном слое: ' + str(self.layer.featureCount()))

            # create an output datasource in memory
            memDriver = ogr.GetDriverByName('MEMORY')
            self.outDS = memDriver.CreateDataSource('memData')
            # open the memory datasource with write access
            self.tmpDS = memDriver.Open('memData', 1)

            self.templayer = self.outDS.CopyLayer(in_lyr, 'temp_layer', ['OVERWRITE=YES'])

        except Exception as err:
            self.setTextStyle('red', 'bold')
            self.textEdit.append('\nНе удалось создать временный слой! ' + str(err))

    def removeZeroPointsFromMemory(self):
        # далее работаем с временным слоем
        if self.templayer is not None:
            self.setTextStyle('green', 'bold')
            self.textEdit.append('Временный слой успешно создан!')
            self.setTextStyle('black', 'normal')
            self.textEdit.append('Количество точек во временном слое: ' + str(self.templayer.GetFeatureCount()))
            # -------- удаляем нулевые точки ---------------
            if self.checkBox.isChecked:
                self.textEdit.append('\nНачинаем удаление нулевых точек...')
                try:
                    for i in range(self.templayer.GetFeatureCount()):
                        feat = self.templayer.GetNextFeature()
                        if feat is not None:
                            geom = feat.geometry()
                            if geom.GetX() == 0.0 and geom.GetY() == 0.0:
                                self.templayer.DeleteFeature(feat.GetFID())
                                self.inDS.ExecuteSQL('REPACK ' + self.templayer.GetName())
                                # self.textEdit.append(str(feat.GetField("TIME")))
                    self.templayer.ResetReading()
                    self.setTextStyle('green', 'bold')
                    self.textEdit.append('Нулевые точки успешно удалены!')
                    self.setTextStyle('black', 'normal')
                    self.textEdit.append(
                        'Количество точек после удаления нулевых: ' + str(self.templayer.GetFeatureCount()))
                except Exception as err:
                    self.setTextStyle('red', 'bold')
                    self.textEdit.append('\nНе удалось удалить нулевые точки! ' + str(err))

            self.outDS.SyncToDisk()

    def saveTempLayerToFile(self):
        # -------- сохраняем результат в шейпфайл (код рабочий) ----------------------
        try:
            fileDriver = ogr.GetDriverByName('ESRI Shapefile')
            fileDS = fileDriver.CreateDataSource(self.filepath)
            newDS = fileDriver.Open(self.filepath, 1)

            self.newlayer = fileDS.CopyLayer(self.templayer, self.filename, ['OVERWRITE=YES'])
            if self.newlayer is not None:
                self.uploadLayer(self.filepath, self.filename, 'ogr')
                self.setTextStyle('green', 'bold')
                self.textEdit.append('Слой успешно загружен в QGIS!')
                self.setTextStyle('black', 'normal')
            del fileDS
        except Exception as err:
            self.setTextStyle('red', 'bold')
            self.textEdit.append('\nНе удалось сохранить файл! ' + str(err))

        del self.inDS, newDS, self.outDS, self.tmpDS

    def azimutCalc(self, x1, x2):
        dX = x2[0] - x1[0]
        dY = x2[1] - x1[1]
        dist = math.sqrt((dX * dX) + (dY * dY))
        dXa = math.fabs(dX)
        if dist != 0:
            beta = math.degrees(math.acos(dXa / dist))
            if (dX > 0):
                if (dY < 0):
                    angle = 270 + beta
                else:
                    angle = 270 - beta
            else:
                if (dY < 0):
                    angle = 90 - beta
                else:
                    angle = 90 + beta
            return angle
        else:
            return 0

    def mainAzimutCalc(self):
        # ------ основная часть плагина -------------------------
        self.textEdit.append('\nНачинаем удаление избыточных точек...')
        try:
            feat_list = []
            for i in range(self.templayer.GetFeatureCount()):
                feat = self.templayer.GetNextFeature()
                feat_list.append(feat)
            self.templayer.ResetReading()

            # отсортируем список по fid
            feat_list = sorted(feat_list, key=lambda feature: feature.GetFID(), reverse=False)

            # for i in feat_list:
            #     self.textEdit.append(str(i.GetFID()))

            accuracy = 10
            partsFlightList = []
            ids_list = []
            i = 0
            while i + 2 < len(feat_list):
                azimut_1 = self.azimutCalc([feat_list[i].geometry().GetX(), feat_list[i].geometry().GetY()],
                                           [feat_list[i + 1].geometry().GetX(), feat_list[i + 1].geometry().GetY()])
                azimut_2 = self.azimutCalc([feat_list[i + 1].geometry().GetX(), feat_list[i + 1].geometry().GetY()],
                                           [feat_list[i + 2].geometry().GetX(), feat_list[i + 2].geometry().GetY()])

                if math.fabs(azimut_1 - azimut_2) < accuracy:
                    ids_list.append(feat_list[i].GetFID())
                else:
                    if ids_list is not None:
                        partsFlightList.append(ids_list)
                    ids_list = [feat_list[i].GetFID()]
                i += 1

            if ids_list is not None:
                ids_list.append(feat_list[i].GetFID())
                ids_list.append(feat_list[i+1].GetFID())
                partsFlightList.append(ids_list)

            self.setTextStyle('green', 'bold')
            self.textEdit.append('Избыточные точки успешно удалены!')
            self.setTextStyle('black', 'normal')
            self.textEdit.append('Количество частей полетов: ' + str(len(partsFlightList)))

            longest_list = max(len(elem) for elem in partsFlightList)
            self.textEdit.append('Самый длинный полет: ' + str(longest_list))
            shortest_list = min(len(elem) for elem in partsFlightList)
            self.textEdit.append('Самый короткий полет: ' + str(shortest_list))

            # анализируем длины полетов и удаляем точки
            for list in partsFlightList:
                if len(list) < longest_list / 2:
                    for fid in list:
                        self.templayer.DeleteFeature(fid)
                        self.inDS.ExecuteSQL('REPACK ' + self.templayer.GetName())
            self.templayer.ResetReading()
            self.textEdit.append('\nКоличество точек в полученном слое: ' + str(self.templayer.GetFeatureCount()))

        except Exception as err:
            self.setTextStyle('red', 'bold')
            self.textEdit.append('\nНе удалось удалить избыточные точки! ' + str(err))

        self.outDS.SyncToDisk()

    def doResult(self):
        self.setTextStyle('black', 'normal')
        self.textEdit.setText('')

        self.getLayer()
        self.getFilepath()

        self.layerToMemory()
        self.removeZeroPointsFromMemory()
        self.mainAzimutCalc()
        self.saveTempLayerToFile()






